import { ActivityType, ActivityData, ActivityMetadata } from "../../../typedefs/activity";
import { JobContext } from "../../../typedefs/job";
import { RestoreJobContextError, 
         MapInputDataError, 
         SubscribeToResponseError, 
         RegisterTimeoutError, 
         ExecActivityError, 
         DuplicateActivityError} from '../../../modules/errors';
import { PubSubDBService } from "..";
import { Signal } from "../../../typedefs/signal";
import { ILogger } from "../../logger";

/**
 * Both the base class for all activities as well as a class that can be used to create a generic activity.
 * This activity type is useful for precalculating values that might be used repeatedly in a workflow,
 * allowing downstream activities to use the precalculated values instead of recalculating them.
 * 
 * The typical flow for this type of activity is to restore the job context, map in upstream data,
 * get the list of subscription patterns and then publish to trigger downstream activities.
 */
class Activity {
  config: ActivityType;
  data: ActivityData;
  metadata: ActivityMetadata;
  context: JobContext;
  pubsubdb: PubSubDBService;
  logger: ILogger;

  constructor(config: ActivityType, data: ActivityData, metadata: ActivityMetadata, pubsubdb: PubSubDBService, context?: JobContext) {
    this.config = config;
    this.data = data;
    this.metadata = metadata;
    this.pubsubdb = pubsubdb;
    this.context = context;
    this.logger = this.pubsubdb.logger;
  }

  async process(): Promise<string> {
    try {
      await this.restoreJobContext();
      await this.mapInputData();
      await this.subscribeToResponse();

      /////// MULTI ///////
      const multi = this.pubsubdb.store.getMulti();
      await this.saveActivity(multi);
      await this.saveActivityStatus(multi);
      await this.subscribeToHook(multi);
      await multi.exec();
      /////// MULTI ///////

      await this.registerTimeout();
      await this.execActivity();
      return this.context.metadata.aid;
    } catch (error) {
      this.logger.error('activity.process:error', error);
      if (error instanceof DuplicateActivityError) {
      } else if (error instanceof RestoreJobContextError) {
      } else if (error instanceof MapInputDataError) {
      } else if (error instanceof SubscribeToResponseError) {
      } else if (error instanceof RegisterTimeoutError) {
      } else if (error instanceof ExecActivityError) {
      } else {
      }
    }
  }

  async restoreJobContext(): Promise<void> {
    if(!this.context) {
      //todo: restore job context if not passed in
      throw new RestoreJobContextError();
    } else {
      this.context[this.metadata.aid] = {
        input: {
          data: this.data,
          metadata: this.metadata,
        },
        output: {
          data: {},
          metadata: {},
        },
      };
    }
  }

  async mapInputData(): Promise<void> {
    // Placeholder for mapInputData
  }

  async subscribeToResponse(): Promise<void> {
    // Placeholder for subscribeToResponse
  }

  async registerTimeout(): Promise<void> {
    // Placeholder for registerTimeout
    //throw new RegisterTimeoutError();
  }

  async execActivity(): Promise<void> {
    // Placeholder for execActivity
    //throw new ExecActivityError();
  }

  /**
   * saves activity data; (NOTE: This data represents a subset of the incoming event payload.
   * those fields that are not specified in the mapping rules for other activities will not be saved.)
   */
  async saveActivity(multi?): Promise<void> {
    const jobId = this.context.metadata.jid;
    const activityId = this.metadata.aid;
    await this.pubsubdb.store.setActivity(
      jobId,
      activityId,
      this.context[activityId].output.data,
      { ...this.metadata,
        jid: jobId,
        key: this.context.metadata.key
      },
      this.pubsubdb.getAppConfig(),
      multi,
    );
  }

  /**
   * update the job collation key to indicate that the activity is running (1)
   * @param multi 
   */
  async saveActivityStatus(multi?): Promise<void> {
    await this.pubsubdb.store.updateJobStatus(
      this.context.metadata.jid,
      -this.config.collationInt,
      this.pubsubdb.getAppConfig(),
      multi
    );
  }

  /**
   * if this activity has `hook` config, it means it should sleep and NOT publish
   * to activate the next downstream activity. only the key that is generated by this method
   * will awaken the activity.
   * 
   * TODO: construct the key (and/or gate) in a way that is unique to the activity
   * 
   * @example
   * hooks:
   *   lob.1.order.routed:
   *     - to: route
   *       conditions:
   *         gate: and
   *         match:
   *           - expected: "{schedule.output.data.id}"
   *             actual: "{$self.hook.data.id}"
   * 
   * @param multi 
   */
  async subscribeToHook(multi?): Promise<void> {
    if (this.config.hook) {
      const hook = this.config.hook;
      const signal: Signal = {
        topic: hook.topic,
        resolved: this.context.metadata.jid,
        jobId: this.context.metadata.jid,
      }
      await this.pubsubdb.store.setSignal(signal, this.pubsubdb.getAppConfig(), multi);
    }
  }
}

export { Activity, ActivityType };
